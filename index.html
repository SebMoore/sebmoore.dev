<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sebastian Moore</title>
    <link rel="icon" type="image/x-icon" href="img/favicon.ico">

    <style>
        
    @import url('https://fonts.googleapis.com/css2?family=Montserrat&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        html, body {
            margin: 0;
            display: block;
            height: 100%;
            overscroll-behavior: contain;
        }
    
    #c {
        width: 100%;
        height: 100%;
        display: block;
    }
    .footer {
        font-family: 'Montserrat', sans-serif;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        background-color: #292929;
        color: rgb(255, 255, 255);
        text-align: center;
    }
    /* Tooltip styling */
    .tooltip {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black; /* If you want dots under the hoverable text */
    }

    .tooltip .tooltiptext {
        visibility: hidden;
        background-color: #555;
        color: #fff;
        text-align: center;
        padding: 5px 0;
        border-radius: 6px; 
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -140px;    
        opacity: 0;
        transition: opacity 0.3s;
    }

    .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: #555 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
    }
    /* Make footer elements on one line */
    #parent { white-space: nowrap; }
    .child { display: inline-block; } 
    #github {
        position: relative;
        float: right;
        top: 50%;
        -ms-transform: translateY(25%);
        transform: translateY(25%);
        padding-right: 10px;
    }
    .header {
        font-family: 'VT323', sans-serif;
        position: fixed;
        width: 100%;
        overflow: hidden;
        background-color: transparent;
        padding: 10px 10px;
    }
    .header a {
        float: left;
        color: white;
        text-align: center;
        padding: 12px;
        text-decoration: none;
        font-size: 30px;
        line-height: 25px;
        border-radius: 4px;
    }
    .header a.logo {
        font-size: 50px;
        font-weight: bold;
    }

    .header-right {
        float: right;
        padding-right: 20px;
    }
    .header-right a:hover {
        background-color: #ddd;
        color: black;
    }
    .modal-window {
        font-family: 'VT323', sans-serif;
        font-size: 20px;
	    position: fixed;
	    background-color: rgba(255, 255, 255, 0.25);
	    top: 0;
	    right: 0;
	    bottom: 0;
	    left: 0;
	    z-index: 999;
	    visibility: hidden;
	    opacity: 0;
	    pointer-events: none;
	    transition: all 0.3s;
    }
    .modal-window:target {
	    visibility: visible;
	    opacity: 1;
	    pointer-events: auto;
    }
    .modal-window > div {
	    width: 400px;
	    position: absolute;
	    top: 50%;
	    left: 50%;
	    transform: translate(-50%, -50%);
	    padding: 2em;
	    background: white;
    }
    .modal-window header {
	    font-weight: bold;
    }
    .modal-window h1 {
	    font-size: 150%;
	    margin: 0 0 15px;
    }
    .modal-close {
	    color: #aaa;
	    line-height: 50px;
	    font-size: 80%;
	    position: absolute;
	    right: 0;
	    text-align: center;
	    top: 0;
	    width: 70px;
	    text-decoration: none;
    }
    .modal-close:hover {
	    color: black;
    }

    a {
    	color: inherit;
    }
    .container {
    	display: grid;
    	justify-content: center;
    	align-items: center;
    	height: 100vh;
    }
    .modal-window > div {
    	border-radius: 1rem;
    }
    .modal-window div:not(:last-of-type) {
    	margin-bottom: 15px;
    }
    @media screen and (max-width: 500px) {
        .header a {
            float: none;
            display: block;
            text-align: left;
        }
        .header-right {
            float: none;
        }
        .header a.logo {
        font-size: 40px;
        }
        .footer {
            font-size: 10px;
        }
        #github {
            position: relative;
            float: right;
            top: 50%;
            -ms-transform: translateY(15%);
            transform: translateY(15%);
            padding-right: 10px;
            padding-bottom: 10px;
        }
        .modal-window > div {
	    width: 150px;
        font-size: 15px;
        }
    }
    @media screen and (max-width: 330px) {
        .header a.logo {
        font-size: 35px;
        }
    }
    .center {
        display: block;
        margin-left: 50%;
        transform: translateX(-50%);
        width: 110%;
    }

    </style>
    <div class="header">
        <a class="logo"></a>
        <div class="header-right">
            <a href="https://github.com/sebmoore" target="_blank" rel="noopener">Code</a>
            <a href="https://behance.net/sebmoore" target="_blank" rel="noopener">Art</a>
            <a href="#contact-modal">Contact</a>

        </div>
    </div>
    <div id="contact-modal" class="modal-window">
        <div>
              <a href="#" title="Close" class="modal-close">Close</a>
              <h1>Contact:</h1>
              <img src="img/contact.png" class="center" >
        </div>
    </div>
</head>
<body>
    <script src="js/typewriter.js"></script>
    <script>
        var app = document.getElementsByClassName("logo")[0];
        document.addEventListener("DOMContentLoaded", function() {
            var typewriter = new Typewriter(app, {
                delay: 75,
                cursor: '_',
            });
        
            typewriter
                .pasteString('> ')
                .pauseFor(1000)
                .typeString('Sebastian Moore')
                .start();
        });

    </script>
    <script src="js/three.min.js"></script>
    <script src="js/lib/postprocessing/EffectComposer.js"></script>
    <script src="js/lib/postprocessing/RenderPass.js"></script>
    <script src="js/lib/postprocessing/ShaderPass.js"></script>
    <script src="js/lib/postprocessing/UnrealBloomPass.js"></script>
    <script src="js/lib/shaders/FocusShader.js"></script>
    <script src="js/lib/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/lib/shaders/CopyShader.js"></script>
    <script src="js/lib/shaders/ConvolutionShader.js"></script>
    <script src="js/require.js"></script>
    <script>
        const meshes = [], variables = [];
        var firstrun = true;
        const clock = new THREE.Clock();
        const rHalf = 10;
        const effectController = {
				showDots: true,
				showLines: true,
				minDistance: 5,
				limitConnections: false,
				maxConnections: 10,
				particleCount: 50
			};
        window.linepositions = new Float32Array(3000000);
        window.colors = new Float32Array(3000000);
        var objects = [];

        init();
		animate();
        function init() { 

            const container = document.querySelector('#container');
		    window.camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 50000 );
		    camera.position.set( 0, 0, 4000 );

            //Change camera position based on aspect ratio
            var ratio = window.innerWidth / window.innerHeight;
            if (ratio < 0.5) {
                camera.position.set( 0, 0, 6000 );
            } else if (ratio < 0.75) {
                camera.position.set( 0, 0, 5000 );
            } else if (ratio < 1.25) {
                camera.position.set( 0, 0, 4000 );
            } else {
                camera.position.set( 0, 0, 3000 );
            }

		    window.scene = new THREE.Scene();
		    scene.background = new THREE.Color( 0x000104 );
		    scene.fog = new THREE.FogExp2( 0x000104, 0.0001 );
		    camera.lookAt(scene.position);
		    const loader = new THREE.OBJLoader();
		    loader.load( 'models/text.obj', function ( object ) {
		    	const positions = combineBuffer( object, 'position' );
		    	createMesh( positions, scene, 4, 0, 0, 0, 0xff7744 );
		    } );

            //Set up renderer
            window.renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(window.innerWidth, (window.innerHeight * 0.999));
            renderer.autoClear = false;
		    document.body.appendChild(renderer.domElement);

            //Set up mouse controls
            var mouseTolerance = 0.7;
            document.onmousemove = function (e) {
                var centerX = window.innerWidth * 0.5;
                var centerY = window.innerHeight * 0.5;
                camera.position.x = (e.clientX - centerX) * 0.5 *mouseTolerance;
                camera.position.y = (e.clientY - centerY) * -0.5 * mouseTolerance;
            };  

            document.ontouchmove = function (e2) {
                var centerX = window.innerWidth * 0.5;
                var centerY = window.innerHeight * 0.5;
                camera.position.x = (e2.touches[0].clientX - centerX) * 1 *mouseTolerance;
                camera.position.y = (e2.touches[0].clientY - centerY) * -1 * mouseTolerance;  
            };

            window.objectparent = new THREE.Object3D();
		    scene.add(objectparent);

            window.grid = new THREE.Points( new THREE.PlaneGeometry( 15000, 25000, 80, 64 ), new THREE.PointsMaterial( { color: 0x4000ff, size: 30 } ) );
		    grid.rotation.x = - Math.PI / 2;
            grid.position.y = -300;
		    objectparent.add(grid);

		    // Postprocessing
		    const renderModel = new THREE.RenderPass( scene, camera );
            const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 100, 100);
			bloomPass.threshold = 0;
			bloomPass.strength = 1;
			bloomPass.radius = 0;
		    window.effectFocus = new THREE.ShaderPass( THREE.FocusShader );
		    effectFocus.uniforms[ "screenWidth" ].value = window.innerWidth * window.devicePixelRatio;
		    effectFocus.uniforms[ "screenHeight" ].value = window.innerHeight * window.devicePixelRatio;
		    window.composer = new THREE.EffectComposer( renderer );
		    composer.addPass( renderModel );
            composer.addPass( bloomPass );
            composer.addPass( effectFocus );

            //Set up resize handler
            window.addEventListener('resize', onWindowResize);

            const linegeo = new THREE.BufferGeometry();
            linegeo.setAttribute( 'position', new THREE.BufferAttribute( linepositions, 3 ).setUsage( THREE.DynamicDrawUsage ) );
            linegeo.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setUsage( THREE.DynamicDrawUsage ) );

            linegeo.computeBoundingSphere();

            linegeo.setDrawRange( 0, 0 );

            const linemat = new THREE.LineBasicMaterial( {
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                color: 0xff0011
            } );
            linesMesh = new THREE.LineSegments( linegeo, linemat );
            objects.push(linesMesh);
            objectparent.add( linesMesh );
            linesMesh.scale.x = linesMesh.scale.y = linesMesh.scale.z = 4
            linesMesh.position.y = -300;

    
        }
        function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
		    	camera.updateProjectionMatrix();
		    	camera.lookAt( scene.position );
		    	renderer.setSize( window.innerWidth, window.innerHeight );
		    	composer.setSize( window.innerWidth, window.innerHeight );
		    	effectFocus.uniforms[ "screenWidth" ].value = window.innerWidth * window.devicePixelRatio;
		    	effectFocus.uniforms[ "screenHeight" ].value = window.innerHeight * window.devicePixelRatio;
        }
        function combineBuffer( model, bufferName ) {       
            var count = 0;
            model.traverse( function ( child ) {
                if ( child.isMesh ) {
                    const buffer = child.geometry.attributes[ bufferName ];
                    count += buffer.array.length;                
                }            
            } );
            const combined = new Float32Array( count );
            let offset = 0;
            model.traverse( function ( child ) {            
                if ( child.isMesh ) {                
                    window.buffer = child.geometry.attributes[ bufferName ];                
                    combined.set( buffer.array, offset );
                    offset += buffer.array.length;                
                }            
            } );
            return new THREE.BufferAttribute( combined, 3 );
        }

        function createMesh( positions, scene, scale, x, y, z, color ) { 
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', positions.clone() );
            geometry.setAttribute( 'initialPosition', positions.clone() );            
            geometry.attributes.position.setUsage( THREE.DynamicDrawUsage );                                       
            mesh = new THREE.Points( geometry, new THREE.PointsMaterial( { size: 30, color: 0x3b82f5 } ) );
            mesh.scale.x = mesh.scale.y = mesh.scale.z = scale;
            mesh.position.y = -300
            mesh.position.x = -40           
            objectparent.add(mesh);
            meshes.push( {
                mesh: mesh, verticesDown: 0, verticesUp: 0, direction: 0, speed: 15, delay: Math.floor( 200 + 200 * Math.random() ), start: Math.floor( 100 + 200 * Math.random() ), variables: variables,
            } );

        }

        function animate() {
            camera.lookAt(new THREE.Vector3(0,-100,0));
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            let delta = 10 * clock.getDelta();     
            delta = delta < 2 ? delta : 2;        
            const data = meshes[0];
            const positions = data.mesh.geometry.attributes.position;
            const initialPositions = data.mesh.geometry.attributes.initialPosition;        
            const count = positions.count;
            if (firstrun) {
                const initcount = 10000
                for ( let i = 0; i < initcount; i ++ ) {          
                    const px = Math.floor(Math.random() * 600) * (Math.round(Math.random()) ? 1 : -1)
                    const py = Math.floor(Math.random() * 600) * (Math.round(Math.random()) ? 1 : -1)
                    const pz = Math.floor(Math.random() * 600) * (Math.round(Math.random()) ? 1 : -1)
                    positions.setXYZ(
                                i,
                                px,
                                py,
                                pz
                    ); 
                }
                firstrun = false;
            }
            if ( data.start > 0 ) {            
                data.start -= 1;            
            } else {            
                if ( data.direction === 0 ) {                
                    data.direction = - 1;                
                }            
            }
            for ( let i = 0; i < count; i ++ ) {            
                const px = positions.getX( i );
                const py = positions.getY( i );
                const pz = positions.getZ( i );
            
                const ix = initialPositions.getX( i );
                const iy = initialPositions.getY( i );
                const iz = initialPositions.getZ( i );
            
                const dx = Math.abs( px - ix );
                const dy = Math.abs( py - iy );
                const dz = Math.abs( pz - iz );
            
                const d = dx + dy + dx;                
                if ( d > 1 ) {                    
                    positions.setXYZ(
                        i,
                        px - ( px - ix ) / 20  * Math.random(),
                        py - ( py - iy ) / 10 * Math.random(), 
                        pz - ( pz - iz )  / 20 * Math.random()
                    );                    
                } else {                    
                    data.verticesUp += 1;                    
                }                          
            }             
            // All points in position
            if ( data.verticesUp >= count ) {            
                if ( data.delay <= 0 ) {                
                    data.direction = - 1;
                    data.speed = 15;
                    data.verticesUp = 0;
                    data.delay = 120;                
                } else {                
                    data.delay -= 1;                
                }            
            }        
            positions.needsUpdate = true;
            
            
        composer.render( 0.01 );
        }
    </script>
    
</body>
<footer>
<div class="footer">
    <div id="parent">
        <div class="child"><p>© 2021 Sebastian Moore - </p></div>
        <div class="child">
            <div class="tooltip">Hover for legal info
                <span class="tooltiptext">WebGL® 2021 Khronos Group Inc.<br/>WebGL and Three.js are licensed<br/>under the MIT License.</span>
            </div>
        </div>
        <div id="github">
            <a href="https://github.com/SebMoore/sebmoore.dev">
                <img alt="Github" src="img/github.png" width=30 height=30>
            </a>
        </div>
    </div> 
    
  </div>
</footer>
</html>